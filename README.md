<p align="center">
    <img width="100" src="https://cdn1.savepice.ru/uploads/2020/9/14/2bf770bded52d8a3cf4fde7479eb1b02-full.png" title="Doomarket">
</p>


<h2 align="center">Doomarket</h2>

#### Doomarket - Cart Functionality market ####

#### Foreword/Предисловие
Данный проект создавался преимущественно в целях демонстрации возможностей фреймворка Django на языке программирования Python. Хотя небольшая часть проекта так же демонстрирует работу и с Frontend технологиями, все же акцент больше сделан на работе разработчика (меня) с технологиями именно фреймворка Django. От этого не исключены небольшие недоработки по Frontend части сайта, где большая часть времени была выделена и отдана на разработку Backend составляющих. При всем этом так же хотелось бы отметить, что небольшие недоработки в той или инной мере так же могут присутствовать и в Backend части, что естественно будет дорабатываться в последующих <a href="#Release2">релизах</a> и некоторые недоработки уже отражены в задачах на последующие релизы.<br><br>
Так же хотелось бы отметить, что перенос отдельных задач на последующие релизы обуславливается: их схожей функциональностью с уже имеющимися технологиями на сайте, с выделением времени на более приоритетные задачи (поскольку каждую технологию необходимо изучить, понять как она работает и реализовать на сайте)   

#### Description/Описание
Doomarket - является e-commerce, cart functionality сайтом (интернет-магазином), реализованным по шаблону проектирования Model-View-Controller. Архитектура модели построена по классической <a href="https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model">Entity–attribute–value-модели</a>. Модель включает в себя взаимодействие друг с другом: значениий товаров, свойств товаров, собственно самих товаров и типов товаров. Более подробно про модель описано в разделе <a href="#EAV">*"ORM, описание EAV модели сайта"*.</a> <br><br>
По возможности код написан таким образом, что вся бизнес логика, утилиты и миксины вынесены за пределами *Views* и *Models*. Насколько возможно, в рамках собственной квалификации был соблюден принцип DRY.
- На сайте присутствуют разделы категорий товаров, подкатегорий товаров и типов товаров - с аналогичным каждому из объектов ассортиментом. <br><br>
- Так же в разделе "Тип товара" присутствуют фильры сортировки продуктов по характеристикам товара (свойствам и значениям). К сожалению на данный момент фильтры ограничены функцианированием только внутри приложения shop, от чего взаимодействие с ними через административную панель не ведется и ограничивает их функционал. Но для общей демонстрации, полагаю, этого будет достаточно. В дальнейших релизах фильтры будут перенесены в отдельное приложение где их функции будут более обширными. С работой и взаимодействием с фильтрами более подробно можно ознакомиться в главе "Использование"-"Приложение shop"-"business-пакет бизнес логики"-"filters.py"<br><br>
- Каждый товар имеет карточку товара внутри которой расположено название товара, артикул, слайдер с изображениями товара, краткие характеристики каждого товара, описание товара, функция добавить в корзину, цена, слайдер рекомендаций товаров по наиболее часто приобретаемым продуктам и подробные характеристики.<br><br>
- Рекомендации товаров полностью функционируют и работают верно, но на данный момент реализованы не до конца, по это причине работу рекомендацй в полной мере можно будет рассмотреть только в shell. Тестирование работы рекомендаций, можно посмотреть в разделе "Использование" - "Приложение shop" - "business-пакет бизнес логики"-"recommender.py"<br><br>
- Корзина реализована за счет подсистемы сессий Django. Ajax-запросов добавления товаров в корзину, к сожалению не реализовано, по причине экономия времени, поскольку в той или инной мере похожим образом, за счет Ajax-запросов реализован функционал у фильтров. Тем самым осуществлена демонстрация работы с Ajax. Корзина включает в себя добавленные продукты, возможность удалять продукты из корзины, менять количество продуктов, добавлять выбранные тованы на оформление заказа. Подробнее про корзину можно прочитать в главе "Использование" - "Приложение cart"<br><br>
- В коризне присутствует возможность вводить промо-коды на скидку, подробнее в разделе "Использование" - "Приложение coupons"<br><br>
- Оформление заказа отправляет данные клиента в административную панель. В следующих релизах планируется добавление платежной системы, на данный момент система не реализована по причине технических неполадок с Erlang. Но если у Вас есть возможность запустить сервер RabbitMQ на этот случай присутствует Celety таск по отправке уведомления клиенту на почту, после заказа. Установка RabbitMQ и реализация таска будет продемонстрирована в разделе "Установка" и "Использование" - "Приложение orders" - "Celery"<br><br>
- На все страницы со списками продуктов реализована пагинация.<br><br>
- В футере сайта доступна интернацианализация (мультиязычность). Все основные функции перевода добавлены, работа с переводом продемонстрирована. Перевод осуществлен не полностью, так как по большей части это уже работа с контентом, а не разработка. Показаны основные возможности перевода.<br><br>
- Реализованы авторизация, регистрация, восстановление пароля.<br><br>
- Добавлены Flatpages для создания шаблонов и добавления контента на них через административную панель.

#### Description of Release 1.0/Общее описание релиза 1.0
Приложение shop:
- Entity–attribute–value-модель
- Продукты
- Свойства продуктов
- Значения свойств продуктов
- AJAX Фильтрация свойств продуктов
- Регистрация, вход, восстановление пароля
- Каталог товаров, разделенный на категории
- Рекомендации
- Утилита генерация slug-a, транслит поля name
- Перевод
- Пагинация
- Поиск
- Тесты Views, Urls

Приложение orders:
- Оформление заказа
- Celery task на отправку уведомлений клиенту
- Экспорт заказов в CSV

Приложение cart:
- Добавление продуктов в корзину товаров
- Форма добавления по количеству товаров прямо из списка товаров, из карточки и в самой корзине
- Подсчет общей стоимости товаров путем сложения всех цен
- Удаление товаров из корзины
- Добавлен простой контекстный процессор, показывающий количество товаров в корзине

Приложение coupons:
- Пересчет общей стоимости цены в корзине с учетом промо-кода
- Пересчет общей стоимости цены в оформлении заказа с учетом промо-кода
- Добавление учета пересчета цены в оформление заказа, оформление по цене дисконта
- Добавление учета дисконта в административную панель и учет дисконта в заказе

Frontend:
- Виджет OWL Carousel
- Карусель в карточках товаров
- JQuery Кнопка наверх

С демонстраций этих и многих других функций вы можете ознакомиться полностью установив проект с виртуальным окружением на свою операционную систему. Инструкция по установке указана в разделе "Установка"

#### <a name="#Release2">Description of Release 2.0/Описание ожидаемых изменений релиза 2.0</a>
- Избранное:
  + Демонстрацию избранного в полной мере осуществляет работа с корзиной и выполняет похожие функции, поэтому избранное будет добавлено позже.

- Генерация PDF-счетов:
  + Будет добавлена возможность генерировать pdf-счета заказов и отправлять их по почте после обработки заказа.

- Отдельное приложение фильтров:
  + Работу фильтров в полной мере демонстрирует класс FiltersPropertyValuesList. Поскольку это не удобный функционал для взаимодействия с ними, через административную панель, так же фильтры должны отличаться по типу фильтра (диапазональный, текстовый и т.д) - перенос фильтров как отдельное приложение планируется.
  
- CSV-парсер отдельное приложение:
  + Основную работу с экспортом в csv формат сейчас демонстрирует экспорт заказов, но с небольшим ограничением. В дальнейших релизах планируется добавление импорта и переноса экспорта с импортом на другие модели, помимо заказов.
 
- Подключение платежного шлюза Braintree:
  + В связи с техническими неполдками в работе с Erlang и не возможнотью протестировать в полной мере работу системы демонстрация платежного шлюза возможна к осуществлению в дальнейших релизах. На данный момент работу с Celery и брокера Rabbit MQ все же можно продемонстрировать на примере отправки письма по таску Celery.
 
- Купоны по product-type:
  + На данный момент осуществлено базовое взаимодействие с купонами, в дальнейших релизах будет осуществлена разработка над их функциональными качествами такими как: создание купонов и привязка их к конкретным product type что позволит создавать купон на конкретный тип продукта, так же не исключено взаимодействие с product.
  
- Расширенный поиск:
  + На данный момент реализована демонстрация поиска по названию товара, в дальнейших релизах будет осуществлен поиск по свойствам, по значениям, поиск по категориям.

- Полный перевод:
  + В релиз 1.0 перевод был добавлен в качестве демонстрации взаимодействия с `i18n_patterns`, перевод контента не сильно важен для демонстрации разработки, поэтому дальнейшие взаимодействия с переводом будут возобновлены с появлением времени на работу с контентом.
  
- Рекомендации:
  + Работу рекомендаций в полной мере можно протестировать с помощью `Redis` сервера и `py shell`, но на данный момент на сайте сама работа рекомендаций находится в разработке. Сам функционал рекомендаций полностью готов и протетирован, туториал по тестированию можно найти в разделе "Использование" - "Приложение shop" - "Рекомендации".
  
- Корзина AJAX:
  + На данный момент работа корзины осуществлена с помощью подсистемы сессий Django, без ajax-запросов. В дальнейшем планируется добавление ajax.
  
- Значения:
  + Корректировка модели Value по типу данных в значении, разделение значения на булевое, числовое, текстовое.
  
- Модальные окна в карточке товаров:
  + На данный момент модальные окна в разделе просмотра фотографий в карточке товара - не добавлены. По причине того, что проект создавался с целью демонстрации разработки и взаимодействия с Django фреймворком, а не демонстрации Frontend технологий. Но такая задача поставлена и будет реализована в последующих релизах, как только будут решены остальные задачи в очереди.
  
- Выпадающий список, поиска по категориям:
  + На данный момент выпадающий список категорий, написан на чистом CSS и HTML, без JS. В дальнейшем планируется - открытие списка по щелчку и отображение подкатегорий и типа продуктов при наведении на категорию в списке.

- Адаптирование некоторых страниц:
  + Хоть сайт и адаптирован под мобильные устройства, но к сожалению, не на всех страницах. Верстка в последствии будет доделана.

#### Install/Установка
Перед началом необходимо произвести клонирование репозитория на свою операционную систему.

##### Virtual env. activate/Активация виртуального окружения #####
Windows:
```
 path\to\env\Scripts\activate
```

Linux:
```
source env/bin/activate
```

##### Requirements install/Установка библиотек #####
Windows:
```
pip install requirements.txt
```

Linux:
```
cd 'Project_name'
pip install virtualenvwrapper
mkvirtualenv "name_your_project"
cat requirements.txt
pip3 install -r requirements.txt
```

##### Установка Redis/ Redis install
Redis - хранит ключ каждого купленного товара, по этим ключам будет формироваться рейтинг. Это необходимо для реализации системы, которая будет выдавать покупателям рекомендуемые товары в зависимости от того, что они положили в корзину.

Проект Redis официально не поддерживает Windows.<br>

 - Все настройки подключения Redis хранятся в `settings.py` проекта, в разделе "Redis configuration"
 - Вы можете загрузить различные версии или последнюю версию <a href="github.com/MSOpenTech/redis/releases">Redis</a>
 - Загрузите файл .msi или .zip
 - Извлеките zip-файл в подготовленный каталог
 - Запустите redis-server.exe , вы можете напрямую запустить redis-server.exe, щелкнув или запустив его в командной строке.<br><br>
<img src="https://i.stack.imgur.com/lKqjc.png"><br><br>
 
 
 - Запустите redis-cli.exe после успешного запуска redis-сервера. Вы можете получить к нему доступ и проверить команды, запустив redis-cli.exe<br><br>
<img src="https://i.stack.imgur.com/BenT1.png"><br><br>
 
 - Команда PING используется для проверки работоспособности соединения<br><br>
<img src="https://i.stack.imgur.com/MA66K.png"><br><br> 

 Примечание: Убедитесь в том, что локальный сервер Redis запущен по указанному порту `6379` в `settings.py`, в противном случае локальный сервер Django не будет запущен и выдаст ошибку.<br>
<hr>


##### Установка брокера RabbitMQ/RabbitMQ install
RabbitMQ - это система обмена сообщениями между приложениями он является рекомендуемым брокером для Celery.<br>
С помощью Celery мы выполняем асинхронные задачи на сайте. Такие как отправка клиенту по почте сообщения о заказе. Более подробно в разделе "Приложение orders".<br>

####Важно!: 
#####Имя компьютера в системе должно быть на латинице и в нижнем регистре. Иначе Erlang работать не будет.

- Установить <a href="https://www.erlang.org/downloads">Erlang</a>
- Скачать с официального сайта RabbitMQ <a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8.exe">Installer for Windows systems (from GitHub, recommended)</a>
- <a href="https://www.rabbitmq.com/download.html">Linux installer, в зависимости от дистрибутива</a>
- В поиске набираем CMD и из списка можно выбрать два варианта, консоль от RabbitMQ или консоль от Windows
- Если выбрали от Windows то выполняем команду:
  + ```cd C:\Program Files\RabbitMQ Server\rabbitmq_server-3.6.11\sbin```
- Запускаем установку сервера 
  + ```rabbitmq-service install```
- Проверяем статус сервера 
  + ```rabbitmqctl status```
- Устанавливаем менеджмент плагин 
  + ```rabbitmq-plugins enable rabbitmq_management```
- Делаем рестарт сервера
  + ```rabbitmq-service stop```
  + ```rabbitmq-service start```
  
####Готово
Заходим в административную панель <a href="http://localhost:15672">RabbitMQ</a><br>

Порт: 15672<br>

- Логин: guest
- Пароль: guest
#



###### Установка PostgreSQL и создание базы данных не составит существенных трудностей на Windows. Поскольку данная база данных имеет как визуальное управление базами данных pgAdmin, так и работать в ней можно и через консоль.
##### Поэтому продемонстрируем только установку в консоли Linux:
- Установка:
  + ```sudo apt-get install postgresql pgadmin3 ```
- Среда PostgreSQL:
  + ```sudo	-u postgres psql ```
- Смена пароля для user-а postgres:
  + ```postgres=# \password```
- Создание базы данных:
  + ```postgres=# CREATE DATABASE name_your_database```
- Просмотреть созданные базы данных:
  + ```postgres=# \l```

##

###Getting started/Использование
####<a name="#EAV">ORM structure, EAV-description/Структура ORM в проекте, описание EAV модели сайта</a>
Модели Doomarket построены по модели Entity-Attribute-Value – это модель данных, которая благодаря использованию сущностей, атрибутов и их значений обеспечивает большую гибкость при создании новых данных.<br>

<img src="https://i.stack.imgur.com/CCocZ.png">

#####Database architecture/Cтруктура EAV-модели Doomarket, архитектура базы данных
Для демонстрации внедрения EAV модели показаны сущности(объекты в моделях) только учавствующие в самой EAV-модели. Второстепенные сущности- "Category", "Subcategory", "Img"  и т.д. не указаны. 
#####ProductType;<br> Объект ProductType(Тип продукта) 
<table>
    <thead>
        <th>id</th>
        <th>name</th>
    </thead>
    <tbody>
        <tr>
	        <td>1</td>
	        <td>Смартфон</td>
	    </tr>
	    <tr>
	        <td>2</td>
	        <td>Смарт-часы</td>
	    </tr>
</table>

#####ProductInstance; <br> Объект Product(Конкретный продукт) 
<table>
    <thead>
        <th>id</th>
        <th>product_type_id</th>
        <th>name</th>
    </thead>
    <tbody>
        <tr>
	        <td>1</td>
	        <td>1</td>
	        <td>Samsung galaxy s10</td>
	    </tr>
	    <tr>
	        <td>2</td>
	        <td>1</td>
	        <td>Apple iphone x</td>
	    </tr>
	    <tr>
	        <td>3</td>
	        <td>2</td>
	        <td>Apple Watch</td>
	    </tr>
	    <tr>
	        <td>4</td>
	        <td>2</td>
	        <td>Samsung Watch</td>
	    </tr>
</table>

#####PropertyType; <br> Объект Property(тип характеристики, свойство) 
<table>
    <thead>
        <th>id</th>
        <th>product_type_id</th>
        <th>name</th>
        <th>type</th>
    </thead>
    <tbody>
        <tr>
	        <td>1</td>
	        <td>1</td>
	        <td>Камера</td>
	        <td>Boolean</td>
	    </tr>
	    <tr>
	        <td>2</td>
	        <td>1</td>
	        <td>ОС</td>
	        <td>String</td>
	    </tr>
	    <tr>
	        <td>3</td>
	        <td>2</td>
	        <td>Вес</td>
	        <td>Decimal</td>
	    </tr>
	    <tr>
	        <td>4</td>
	        <td>2</td>
	        <td>Длина ремешка</td>
	        <td>Integer</td>
	    </tr>
</table>

#####PropertyInstance; <br> Объект Value(значение характеристики конкретного продукта) 
<table>
    <thead>
        <th>id</th>
        <th>product_instance_id</th>
        <th>property_type_id</th>
        <th>Value</th>
    </thead>
    <tbody>
        <tr>
	        <td>1</td>
	        <td>1</td>
	        <td>1</td>
	        <td>Да</td>
	    </tr>
	    <tr>
	        <td>2</td>
	        <td>1</td>
	        <td>2</td>
	        <td>Android</td>
	    </tr>
	    <tr>
	        <td>3</td>
	        <td>2</td>
	        <td>1</td>
	        <td>Да</td>
	    </tr>
	    <tr>
	        <td>4</td>
	        <td>2</td>
	        <td>2</td>
	        <td>IOS</td>
	    </tr>
</table>

#### Итог:
Продемонстрированная архитектура в точности копирует модель EAV. Тем самым ORM Django позволяет нам гибко взаимодействовать с свойствами товаров и значениями свойств, что в целом необходимо для целей проекта.
#

##### Briefly about the hierarchy of folders/Краткое описание иерархии проекта
Для полноценной структуры проекта вся бизнес логика утилиты и миксины были вынесены за пределы views, шаблоны рассортированы по директориям.

Для полноценного восприятия структуры проекта, давайте ознакомимся с терминологией:
- директория business
  + Содержит в себе всю бизнес логику, по возможности вынесенную из views
- директория management
  + Содержит утилиты
- директория mixin
  + Содержит миксины классов

Под всеми функциями и классами, даже самыми очевидными оставлены коментарии на английском языке. По возможности были написаны тесты, к сожалению написаны они только в приложении shop и ограничены только views и urls.  

##

#### shop application/Приложение shop
#####views.py
- Функция `register_page` - получает импортированную функцию `register_page`, класса `AccountsView`, для выполнения действий над регистрацией пользователя. Подробнее в "business"-"accounts.py"

- Функция `login_page` - получает импортированную функцию `login_page`, класса `AccountsView`, для выполнения авторизации пользователя. Подробнее в "business"-"accounts.py"

- Функция `logout_user` - получает импортированную функцию `logout_user`, класса `AccountsView`, для выполнения выхода из аккаунта пользователя. Подробнее в "business"-"accounts.py"

- Класс `ProductListView` - получает список активных, продуктов на главной странице. `get_context_data` - отображает форму `CartAddProductForm` для каждого товара, подробнее "Приложение cart"-"forms.py"

- Класс `ProductDetailView` - отвечает за отображение карточки товара каждого из продуктов. 
  + `get_context_data` - отображает форму `CartAddProductForm` для каждого товара, подробнее "Приложение cart"-"forms.py"
  + Форма для шаблона `recommended_products` получает функцию `suggest_products_for`, класса `Recommender`, для отображения предлагаемых товаров, подробнее в "business"-"recommender.py"

- Класс `CategoryDetailView` - отвечает за отображение каталога товаров по категориям
  + Поскольку из-за архитектуры `DetailView` пагинация не предусмотрена, импортируем для этих целей `MultipleObjectMixin` и вносим изменения в `get_context_data`
  + `CategoryList` отвечает за отображения нужного нам списка категорий. Подробнее в "business"-"catalogue.py".
  + `SubcategoryList` отвечает за отображения нужного нам списка подкатегорий. Подробнее в "business"-"catalogue.py".
  + `get_context_data` - отображает форму `CartAddProductForm` для каждого товара, подробнее "Приложение cart"-"forms.py"

- Класс `SubcategoryDetailView` - отвечает за отображение каталога товаров по подкатегориям
   + Поскольку из-за архитектуры `DetailView` пагинация не предусмотрена, импортируем для этих целей `MultipleObjectMixin` и вносим изменения в `get_context_data`
   + `CategoryList` отвечает за отображения нужного нам списка категорий. Подробнее в "business"-"catalogue.py".
   + `SubcategoryList` отвечает за отображения нужного нам списка подкатегорий. Подробнее в "business"-"catalogue.py".
   + `ProductTypeList`отвечает за отображения нужного нам списка типов продуктов. Подробнее в "business"-"catalogue.py".
   + `get_context_data` - отображает форму `CartAddProductForm` для каждого товара, подробнее "Приложение cart"-"forms.py"

- Класс `ProductTypeDetailView` - отвечает за отображение каталога товаров по типам продукта
  + Поскольку из-за архитектуры `DetailView` пагинация не предусмотрена, импортируем для этих целей `MultipleObjectMixin` и вносим изменения в `get_context_data`
  + `CategoryList` отвечает за отображения нужного нам списка категорий. Подробнее в "business"-"catalogue.py".
  + `ProductTypeList`отвечает за отображения нужного нам списка типов продуктов. Подробнее в "business"-"catalogue.py".
  + `FiltersPropertyValuesList` создает визуальную часть фильтров, отвечает за отображение фильтров на странице. Подробнее в "business"-"filters.py".
  + `get_context_data` - отображает форму `CartAddProductForm` для каждого товара, подробнее "Приложение cart"-"forms.py"

- Класс `FilterProductsView` - отвечает за функцианирование фильтров при сортировке фильтрами товаров
  + `JsonProductTypeFilterView` отвечает за сортировку товаров, отправляет данные о выбраном товаре в json формате
  + `CategoryList` отвечает за отображения нужного нам списка категорий. Подробнее в "business"-"catalogue.py".
  + `ProductTypeList`отвечает за отображения нужного нам списка типов продуктов. Подробнее в "business"-"catalogue.py".
  + `FiltersPropertyValuesList` создает визуальную часть фильтров, отвечает за отображение фильтров на странице. Подробнее в "business"-"filters.py".
  
- Класс `Search` - отвечает за поиск товаров
  + `get_queryset` отвечает за возврат списка товаров по критерию `__icontains`, от полученного GET запроса. А именно - это проверка содержания без учета регистра.
  + `get_context_data` дает возможность переходить на другую страницу пагинации, при произведенном поиске без ошибок. 

##

#####urls.py
В данном файле нет ничего необычного и не логичного по взаимодействию с views.py, что хотелось бы затронуть. Вопреки этому хотелось бы оговорить работу подсистемы Django flatpages и работу Django-allauth.

- С работой <a href="https://github.com/django/django/blob/master/django/contrib/auth/views.py">django-allauth можно ознакомиться на официальном github Django в django/django/contrib/auth/views.py</a>, а так же в <a href="https://docs.djangoproject.com/en/3.1/topics/auth/default/#module-django.contrib.auth.views">документации.</a> Для функционирования подсистемы необходимо:
  + Импортируем модуль `from django.contrib.auth import views as auth_views`
  + В файле settings.py внести настройки SMTP `EMAIL_BACKEND`, `EMAIL_HOST`, `EMAIL_PORT`, `EMAIL_USE_TLS`, `EMAIL_HOST_USER`, `EMAIL_HOST_PASSWORD`
    + Примечание: В качестве пароля в `EMAIL_HOST_PASSWORD`, используется сгенерироваанный пароль google для приложений, не пытайтесь зайти им на почту.
  + `name = 'password_reset'` - шаблон ввода почты для отправки на нее сообщения о восстановлении
  + `name = 'password_reset_done'` - шаблон, уведомление о том, что сообщение отправлено
  + `name='password_reset_confirm'` - шаблон на который редиректит с письма, на страницу для ввода новых данных аккаунта
  + `name='password_reset_complete'` - шаблон подтверждающий смену пароля
  
- С работой <a href="https://github.com/django/django/blob/master/django/contrib/auth/views.py">flatpages можно ознакомиться на официальном github Django в django/django/contrib/flatpages/views.py </a>, а так же в <a href="https://docs.djangoproject.com/en/3.1/ref/contrib/flatpages/#using-the-urlconf">документации.</a> Разберем работу с url на примере одного из path:
  + Импортируем модуль `from django.contrib.flatpages import views as flatpages_views`
  + `path('tutorial/',` - путь
  + `flatpages_views.flatpage,` - импортированный модуль
  + `{'url': '/tutorial/'},` - то, что мы написали в административной панели в поле url
  + `name='tutorial'),)` - имя для шаблона
##

###management package/management - пакет утилит
- #####management/utils.py
#####Утилиты приложения shop на данный момент содержат в себе 2 функции относящиеся к генерации slug. Они выполнены следующим образом:

- `gen_slug_clear()` генерирует входящий аргумент, в транслит того же слова (Например поле name введенное на кириллице будет написано транслитом: "машина" > "mashina"). Далее, после транслита, превращает словосочетание в формат slug-а, например если у нас не одно слово а несколько то будет: "хелло ворлд">"hello-world"
- `gen_slug()` выполняет те же функции, что и `gen_slug_clear()`, только добавляет к slug уникальный индефикатор. Используется в случаях где для каждого из объектов требуется уникальность.
##

###business package/business - пакет бизнес-логики
- #####business/accounts.py

Включает в себя класс `AccountsView` и его функции, для регистрации, входа, выхода

- `register_page` производит вход, если форма `CreateUserForm` валидна
- `login_page` производит вход, если получаем из формы метод POST, если пользователь существует редиректим на главную страницу, с соответственным messages, если не существут выдаем соответствующий messages
- `logout_user` производим выход из аккаунта

##

- #####business/catalogue.py
Набор классов с функциями для получения нужных QuerySet

- `CategoryList`
  + `get_category` список всех категорий
  + `get_category_recomendtions` список 2 категорий для отображения

- `SubcategoryList`
  + `get_subcategory_by_category` получение своего QuerySet подкатегорий, для каждой страницы категории
  + `get_product_by_subcategory` получение своего QuerySet продуктов, для каждой страницы подкатегорий

- `ProductTypeList`
  + `get_product_type_by_subcategory` получение своего QuerySet типа продукта, для каждой страницы подкатегорий
##

- #####business/filters.py
Включает себя функции `get_property_`, `get_value_` класса `FiltersPropertyValuesList`, в свою очередь наследующие функции `get_property_name`, `get_value_id` из класса `FiltersPropertyValuesMixin` пакета mixin 

- `FiltersPropertyValuesList`
  + `get_property_width(property_name_which_you_want_on_filter_title)` получает наименование необходимого нам свойства в фильтре, в дальнейшем требует определения этой функции в шаблоне, для отображения названия фильтра
  + `get_value_width(property_id_which_values_you_want_get_to_filter)` поиск осуществляется по id (добавлено для разнообразия). Принимает id свойства значения которого нужны нам в фильтре.
##

- #####business/producttype_filters_querysets/producttype_filters_json.py
- `JsonProductTypeFilterView`
  + `get_queryset` - функция возвращает queryset продуктов полученных в результате сортировки по свойствам, обозначаем поля для рендера
  + `get` - формирует json ответ
##

- #####business/recommender.py
Осуществляет подбор рекомендаций назначая каждому из продуктов рейтинг и отображая рекомендуемые продукты по порядку рейтинга.
- Переменная `connect` сылается к настройкам на подключение локального сервера Redis. Установка Redis подробно описана в главе "Установка"-"Установка Redis"<br><br>
  Настройки settings.py понадобятся, чтобы Django-приложение могло подключиться к серверу Redis
  ```
  # Redis configuration
    REDIS_HOST = 'localhost'
    REDIS_PORT = 6379
    REDIS_DB = 1
  ```
- `Recommender` - реализует сохранение информации о купленных вместе товарах и подбирает рекомендации
  + `get_product_key` получает id товара и формирует ключ для хранилища Redis
  + `product_bought(self, products)` получает список объектов `Product`, получает товары купленные вместе с текущим, увеличивает их рейтинг.
  + `suggest_products_for(self, products, max_result=6)` `products` - список объектов для которых нужно подобрать рекомендации, `max_result` - целое число означающее максимальное количество товаров которые вернет метод
  + `clear_purchases` метод для очистки рекомендаций
  
 - #####Recommendations testing/Тестирование рекомендаций
   + Выполните команду `python manage.py shell`
   + Импортируем модель Product `from shop.models.product import Product`
   + Используем уже созданные товары
   + ```
       >>> black_phone = Product.objects.get(name='Samsung Galaxy S10+ 128 ГБ')
       >>> white_phone = Product.objects.get(name='Samsung Galaxy S20 Ultra 128 Гб')
       >>> watch = Product.objects.get(name='Apple Watch Series 5, 44 мм')
       >>> laptop = Product.objects.get(name='Apple MacBook Pro 13')
     ```
   + Импортируем Recommender `from shop.business.recommender import Recommender`
   + ```
        >>> r = Recommender()
        >>> r.product_bought([black_phone, white_phone])
        >>> r.product_bought([black_phone, watch])
     ```
   + ```
        >>> r.suggest_products_for([black_phone])
     ```
   + В итоге должны получить список продуктов
   + ```
        [<Product: Apple Watch Series 5, 44 мм>,
         <Product: Samsung Galaxy S20 Ultra 128 Гб>]
     ```
##

###mixin package/mixin - пакет миксинов
- #####business/filter_mixin.py
- `FiltersPropertyValuesMixin` - используется для сокращения кода, для `FiltersPropertyValuesList`
  + `get_property_name` ищет имя свойства для фильтра, по имени свойства
  + `get_value_id` ищет значения свойства для фильтра по id
#

#### cart application/Приложение cart
###business - пакет бизнес-логики
- #####business/cart.py
Содержит функции  `__init__`, `add`, `save`, `remove`, `__iter__`, `__len__`, `get_total_price`,`clear`,`coupon`,`get_discount`, `get_total_price_after_discount` класса `Cart` 
- Cart - отвечает за всю функциональность корзины
  + `__init__` в конструктор передан объект запроса request. В request.session запоминаем текущую сессию, чтобы иметь к ней доступ в других методах класса. Получаем данные корзины обращаясь к `self.session.get(settings.CART_SESSION_ID)`, если не получаем объект корзины создаем ее как пустой словарь в сессии. Так же инициализируем объект купона из сессии `self.coupon_id`
  + `add` метод для добавления товаров в корзину и обновления их количства
  + `save` метод помечает сессию как измененную с помощью атрибута modified. Так мы говори Django о том, что редактировали данные сессии, а теперь их необходимо сохранить
  + `remove` данный метод удаляет товар из корзины и сохраняет новые данные сессии обращаясь к методу `save()`
  + `__iter__` создается копия объекта корзины, мы получаем товары сохраненные в ней. Для каждого товара преобразуем цену из строки в число с фиксированной точностью. Вычисляем общую стоимость `'total_price'`, с учетом цены и количества
  + `__len__` возвращаем общее количество единиц товаров, сохраненных в корзине 
  + `get_total_price` подсчет общей стоимости корзины
  + `clear` метод очистки корзины
  + `coupon` определен как свойство класса через декоратор `@property`, если у корзины задан атрибут `coupun_id`, это свойство будет возвращать соответствующий объект купона
  + `get_discount` возвращает размер скидки, если у корзины есть значение в аттрибуте `coupun_id`
  + `get_total_price_after_discount` возвращает общую стоимость товара в корзине, с учетом скидки по купону

#

- #####business/context_processors.py
 `cart` -  функция, в качестве аргумента передается объект запроса request, которая возвращает словарь. Этот словарь будет добавляться в контекст любого шаблона. В функции мы инициируем корзину, передавая в конструктор объект текущего запроса и добавляем в контекст в виде переменной cart
- Так же в `settings.py` в раздел `TEMPLATES`, необходимо добавить `cart.business.context_processors.cart`
#

####views.py
- `cart_add` декортаор `@require_POST`, позволяет обращаться к функции только методом POST. Обработчик принимает id товара в качестве аргумента, по которому мы получаем объект Product из базы данных. Если созданная форма `CartAddProductForm` валидна, добавляем или обнавляем сведения по товару
- `cart_remove` получает id товара в качестве аргумнета, вызывает его из базы данных и удаляет из корзины
- `cart_detail` Отображает корзину основываясь на данных, сохраненных в сессии `request.session`. Добавлена форма купона `CouponApplyForm` в интерфейс магазина
#

#### orders application/Приложение orders
#####models.py
- Модель `Order` - определяет поля для сохранения информации о покупателе
  + `get_total_cost` - получаем общую стоимость товаров в заказе
- Модель `OrderItem` - сохраняем товар, так же сохраняем количество и стоимость для каждого элемента корзины
  + `get_cost` - для получения общей стоимости позиции в корзине
#

####views.py
- `order_create` - обработчик который получает данные из запроса, проверяет на валидность форму `OrderCreateForm` и создает заказ
#

####Export CSV/Экспорт заказов в CSV
Данная функция выполняется когда пользователь выбирает действие на сайте администрирования.
####admin.py
- `export_to_csv` Создается объект класса `HttpResponse`, с типом содержимого `text/csv`, чтобы браузер работал с файлом так же, как с CSV. Добавили заголовок `Content-Disposition`, так как к ответу будет прикреплен файл. Объект writer записывает данные файла в объект response. С помощью метода `get_fields()` опций мета модели, исключая отношение "M2M", "FK". Заглавную строку заполняем названиями полей. Далее проходим по каждому выбранному пользователем элементу и записываем его данные в строку. При этом выполняем форматирование объектов даты datetime, т.к. выходные данные для CSV должны быть представленны в виде строки. `short_description` определяем как будет выглядить.
- Добавлем поле `actions = [export_to_csv]` для модели `admin.py`  

####Celery async/Выполнение ассинхронных задач с Celery
Для дальнейшей работы необходимо запустить локальный сервер брокера Rabbit MQ, его установку и работа с сервером описаны в главе "Установка"-"Установка RabbitMQ"<br>

Далее описывается описывается конфигурация для Celery. В файле doomarket/celery.py настраиваем наш проект на взаимодействие с Celery
- `DJANGO_SETTINGS_MODULE` переменная окружения для консольных команд Celery
- `app = Celery('doomarket')` создаем экземпляр приложения 
- Загружаем конфигурацию из настроек нашего проекта
- Вызываем процесс поиска и загрузки асинхронных задач по нашему проекту.

Необходимо импортировать модуль `celery.py` в файле `__init__.py` проекта, чтобы он выполнялся при старте проекта. Для этого в файле проекта `doomarket/__init__.py` добавлен следующий фрагмент:
```
    # Launch celery
    from celery import app as celery_app
```

####task.py
Таск содержит функцию `order_created`

- `order_created` задача- это функция с декроатором `@task`, получает параметр `order_id`. Чтобы отправлять покупателю сообщения на электронную почту- обращаемся к функции `send_mail`

####ВНИМАНИЕ! Поскольку, во время разработки проекта, функционирование RabbitMQ было не корректным, ассинхронная задача не была подключена.<br><br> Дальнейшие действия необходимо произвести самостоятельно:

- Добавляем вызов асинхронной задачи в обработчик `order_create`, файл views.py
- Импортируем задачу `order_created`
```
    from .task import order_created
```
- После метода `cart.clear()` вставляем следующие строки, для запуска асинхронной задачи
```
   order_created.delay(order.id) 
```
- Метод `delay()` запустит задачу асинхронно, она будет добавлена в очеред Celery
- В консоли необходимо запустить процесс Celery 
```
    celery -A myshop worker -l info
```

Для проверки работоспособности далее необходимо:
 - Запустить сервер 
 - Добавить несколько товаров в корзину, открыть корзину, оформить заказ 
 - После чего в консоли, где вы запустили рабочий процесс Celery должена появиться информация о получении задачи `order.task.order_created` и информация о успешном выполнении задачи `succeeded`
#
    
#### coupons application/Приложение coupons
Создали форму, которую используем для предоставления купона `CouponApplyForm`
#####views.py
- `coupon_apply` проверяет данные купона и сохраняет его в сессии пользователя. Декоратор `@require_POST`, как и ранее используется для того чтобы функция была доступна только при запросах методом POST. Если ранее созданная форма валидна получаем из словаря `cleaned_data` код `code`, введенный пользователем и пытаемся получить соответствующий активный купон. Используем запрос `__iexact`, чтобы проверить код без учета регистра. Купон должен быть активным `active` и подходящим по периоду действия `valid_from__lte`, `valid_to__gte`. Используем `timezone.now()`, чтобы получить объект дат и времени, с учетом временной зоны, а затем его сравниваем с датами начала и окончания действия купона- `valid_from__lte`, `valid_to__gte`. `lte- <=`, `gte >=`. Далее сохраняем id купона в сесии  и редиректим пользователя.<br>

Все остальные действия с добавлением инициализации объекта купона из сессии и методов `coupon` `get_discount` `get_total_price_after_discount` для работы купонов в корзине описаны в разделе "Приложение cart"-"Пакет business"-"cart.py"

#####Coupon purchase/Обрабоотка покупок по купонам
Данный раздел стоило бы продемонстрировать в разделе "Приложение orders". Но для полноты восприятия информации- описание оставим в этом разделе.
- Сохраняет информацию о примененном купоне для каждого заказа. Для этого необходимо было дополнить модель Order, чтобы она была связана с моделью Coupon
#####orders/models.py  
В модель добавили два поля `coupon`, `discount`
 - Метод `get_total_cost` работает с  `discount`, а именно учитывает возможную скидку при рассчете общей стоимости в заказе
 - В данном фрагменте мы создаем объект модели Order с помощью сохранения формы `OrderCreateForm`. Передаем `commit=False`, чтобы объект пока не сохранялся в базу данных. Если для корзины задан купон, сохраняем ссылку на него и размер скидки, после чего заносим объект Order в базу даных
 - ```
    order = form.save(commit=False)
        if cart.coupon:
            order.coupon = cart.coupon
            order.discount = cart.coupon.discount
        order.save()
   ```

#

### Consultancy/Консультирование ###
Мы предоставляем полную консультационную поддержку касательно Doomarket. Пожалуйста, свяжитесь с *grabsomebuds27@gmail.com*, либо *w1ldboyzz@yandex.ru*
 для получения дополнительных пояснений по Вашим вопросам.









